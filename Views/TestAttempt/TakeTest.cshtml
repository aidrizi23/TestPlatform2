@model TestPlatform2.Models.TakeTestViewModel
@using Microsoft.AspNetCore.Mvc.TagHelpers
@using TestPlatform2.Data.Questions
@using TestPlatform2.Models

@{
ViewData["Title"] = "Taking Test: " + Model.Test.TestName;
}

<div class="container">
    <!-- Test Header -->
    <div class="card mb-4">
        <div class="card-header">
            <div class="d-flex justify-content-between align-items-center flex-wrap">
                <h3 class="mb-0"><i class="fas fa-edit me-2"></i>@Model.Test.TestName</h3>
                <div class="d-flex align-items-center">
                    <div class="timer-display me-2">
                        <i class="fas fa-clock me-2"></i>
                        <span id="timer" class="badge bg-primary p-2">@($"{Model.Test.TimeLimit:00}:00")</span>
                    </div>
                    <div class="attempts-display">
                        <i class="fas fa-redo me-2"></i>
                        <span class="badge bg-info p-2">Attempts: <span id="remainingAttemptsCounter">@Model.RemainingAttempts</span></span>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body">
            @if (!string.IsNullOrEmpty(Model.Test.Description))
            {
            <p>@Model.Test.Description</p>
            }

            <div class="progress mb-3" style="height: 10px;">
                <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%;"
                     aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                </div>
            </div>

            <div class="d-flex justify-content-between mb-2">
                <div><strong>Question: <span id="currentQuestionNumber">1</span>/<span id="totalQuestions">@Model.Questions.Count</span></strong></div>
                <div id="questionTypeBadge" class="badge bg-primary"></div>
            </div>
        </div>
    </div>

    <!-- Test Form -->
    <form id="testForm" asp-action="SubmitAnswers" method="post">
        <input type="hidden" asp-for="AttemptId" />
        <input type="hidden" id="remainingAttempts" value="@Model.RemainingAttempts" />

        @if (Model.Questions != null && Model.Questions.Any())
        {
        <!-- Question Container -->
        <div class="card mb-4">
            <div class="card-body">
                @for (int i = 0; i < Model.Questions.Count; i++)
                {
                var question = Model.Questions[i];
                <div class="question-container" data-question-index="@i" data-question-type="@question.GetType().Name.Replace("Question", "")" style="display: none;">
                    <div class="form-group mb-4">
                        <h4 class="mb-4">@question.Text</h4>
                        <input type="hidden" name="answers[@i].QuestionId" value="@question.Id" />

                        @switch (question)
                        {
                        case MultipleChoiceQuestion mcq:
                        <div class="multiple-choice-options">
                            @for (int j = 0; j < mcq.Options.Count; j++)
                            {
                            <div class="form-check custom-option mb-3">
                                <input class="form-check-input" type="@(mcq.AllowMultipleSelections ? "checkbox" : "radio")"
                                       name="answers[@i].Response" id="option-@i-@j" value="@mcq.Options[j]"
                                       data-question-index="@i" />
                                <label class="form-check-label custom-option-label" for="option-@i-@j">
                                    @mcq.Options[j]
                                </label>
                            </div>
                            }

                            @if (mcq.AllowMultipleSelections)
                            {
                            <div class="form-text text-info mb-3">
                                <i class="fas fa-info-circle me-2"></i>
                                You can select multiple answers for this question.
                            </div>
                            }
                        </div>
                        break;

                        case TrueFalseQuestion tfq:
                        <div class="true-false-options d-flex gap-3">
                            <div class="form-check custom-option">
                                <input class="form-check-input" type="radio" name="answers[@i].Response"
                                       id="true-@i" value="True" data-question-index="@i" />
                                <label class="form-check-label custom-option-label" for="true-@i">
                                    <i class="fas fa-check text-success me-2"></i>True
                                </label>
                            </div>
                            <div class="form-check custom-option">
                                <input class="form-check-input" type="radio" name="answers[@i].Response"
                                       id="false-@i" value="False" data-question-index="@i" />
                                <label class="form-check-label custom-option-label" for="false-@i">
                                    <i class="fas fa-times text-danger me-2"></i>False
                                </label>
                            </div>
                        </div>
                        break;

                        case ShortAnswerQuestion saq:
                        <div class="mb-3">
                            <input class="form-control sa-answer" type="text" name="answers[@i].Response"
                                   placeholder="Type your answer here..." autocomplete="off"
                                   data-question-index="@i" />
                            <div class="form-text text-muted">
                                <i class="fas fa-info-circle me-1"></i>
                                Type your answer in the field above. Be precise and check your spelling.
                            </div>
                        </div>
                        break;

                        default:
                        <p class="text-danger">Unsupported question type</p>
                        break;
                        }
                    </div>
                </div>
                }
            </div>
        </div>

        <!-- Navigation Buttons -->
        <div class="d-flex justify-content-between mb-5">
            <button type="button" id="prevBtn" class="btn btn-secondary">
                <i class="fas fa-arrow-left me-2"></i>Previous
            </button>

            <div class="d-flex gap-2">
                <button type="button" id="nextBtn" class="btn btn-primary">
                    Next<i class="fas fa-arrow-right ms-2"></i>
                </button>
                <button type="submit" id="submitBtn" class="btn btn-success" style="display: none;">
                    <i class="fas fa-check-circle me-2"></i>Submit Test
                </button>
            </div>
        </div>
        }
        else
        {
        <div class="alert alert-danger">
            <i class="fas fa-exclamation-triangle me-2"></i>
            No questions available for this test.
        </div>
        }
    </form>

    <!-- Question Navigation -->
    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0"><i class="fas fa-map me-2"></i>Question Navigation</h5>
        </div>
        <div class="card-body">
            <div class="question-nav d-flex flex-wrap gap-2">
                @for (int i = 0; i < Model.Questions.Count; i++)
                {
                <button type="button" class="btn btn-sm btn-outline-secondary question-nav-btn"
                        data-question-index="@i" onclick="goToQuestion(@i)">
                    @(i + 1)
                </button>
                }
            </div>
        </div>
    </div>
</div>

<!-- Security Warning Modal -->
<div class="modal fade" id="securityWarningModal" tabindex="-1" aria-labelledby="securityWarningLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-danger">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title" id="securityWarningLabel">
                    <i class="fas fa-shield-alt me-2"></i>Security Violation Detected
                </h5>
            </div>
            <div class="modal-body text-center">
                <i class="fas fa-exclamation-triangle fa-3x text-danger mb-3"></i>
                <h4>Unauthorized Activity Detected!</h4>
                <p id="securityMessage" class="mb-3">You have attempted to use prohibited tools or actions during the test.</p>
                <div class="alert alert-warning">
                    <strong>Warning:</strong> Continued violations will result in automatic test submission and account restrictions.
                </div>
                <p><strong>Violations: <span id="violationCount">0</span>/3</strong></p>
            </div>
            <div class="modal-footer justify-content-center">
                <button type="button" class="btn btn-primary" onclick="acknowledgeWarning()">
                    <i class="fas fa-check me-2"></i>I Understand - Continue Test
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Attempt Warning Modal -->
<div class="modal fade" id="attemptWarningModal" tabindex="-1" aria-labelledby="attemptWarningLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning">
                <h5 class="modal-title" id="attemptWarningLabel">
                    <i class="fas fa-exclamation-triangle me-2"></i>Warning!
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>You have <strong id="modalRemainingAttemptsCounter">@Model.RemainingAttempts</strong> attempt(s) remaining.</p>
                <p class="text-danger">
                    <i class="fas fa-exclamation-circle me-2"></i>
                    Leaving the page or using restricted features will reduce your remaining attempts.
                </p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">
                    <i class="fas fa-check-circle me-2"></i>Continue Test
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Submission Confirmation Modal -->
<div class="modal fade" id="submitConfirmModal" tabindex="-1" aria-labelledby="submitConfirmLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="submitConfirmLabel">
                    <i class="fas fa-question-circle me-2"></i>Confirm Submission
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to submit your test?</p>
                <div id="unansweredWarning" class="alert alert-warning" style="display: none;">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    You have <strong id="unansweredCount">0</strong> unanswered questions!
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="fas fa-times me-2"></i>Continue Test
                </button>
                <button type="button" class="btn btn-success" id="confirmSubmitBtn">
                    <i class="fas fa-check-circle me-2"></i>Submit Test
                </button>
            </div>
        </div>
    </div>
</div>

<style>
    /* Enhanced security styles */
    body {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
    }

    .container {
        pointer-events: auto;
    }

    /* Prevent text highlighting */
    * {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
    }

    /* Allow input fields to be selectable */
    input, textarea, select {
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
    }

    /* Hide scrollbars to prevent right-click */
    ::-webkit-scrollbar {
        width: 0px;
        background: transparent;
    }

    /* Security overlay for dev tools detection */
    .security-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(220, 38, 38, 0.95);
        z-index: 10000;
        display: none;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 2rem;
        text-align: center;
    }

    /* Fullscreen test mode */
    .test-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        background: white !important;
        overflow-y: auto !important;
    }
</style>

@section Scripts {
<script>
    // Enhanced Anti-Cheat System
    class EnhancedAntiCheat {
        constructor() {
            this.violations = 0;
            this.maxViolations = 3;
            this.isDevToolsOpen = false;
            this.securityCheckInterval = null;
            this.consoleWarnings = 0;
            this.lastActivityTime = Date.now();
            this.init();
        }

        init() {
            this.blockAllKeyboardShortcuts();
            this.blockContextMenu();
            this.blockTextSelection();
            this.blockDragDrop();
            this.detectDevTools();
            this.preventConsoleAccess();
            this.monitorPageVisibility();
            this.preventDebugging();
            this.blockViewSource();
            this.enterFullscreen();
            this.startSecurityChecks();
            this.overrideConsoleMethods();
        }

        blockAllKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                const blockedCombinations = [
                    // Dev Tools
                    {key: 'F12'},
                    {ctrl: true, shift: true, key: 'I'},
                    {ctrl: true, shift: true, key: 'J'},
                    {ctrl: true, shift: true, key: 'C'},
                    {cmd: true, alt: true, key: 'I'}, // Mac
                    {cmd: true, alt: true, key: 'J'}, // Mac
                    {cmd: true, alt: true, key: 'C'}, // Mac

                    // Refresh/Navigation
                    {key: 'F5'},
                    {ctrl: true, key: 'r'},
                    {ctrl: true, key: 'R'},
                    {cmd: true, key: 'r'}, // Mac
                    {alt: true, key: 'ArrowLeft'},
                    {alt: true, key: 'ArrowRight'},
                    {cmd: true, key: 'ArrowLeft'}, // Mac
                    {cmd: true, key: 'ArrowRight'}, // Mac

                    // Copy/Paste/Select/Save/Print
                    {ctrl: true, key: 'c'},
                    {ctrl: true, key: 'v'},
                    {ctrl: true, key: 'x'},
                    {ctrl: true, key: 'a'},
                    {ctrl: true, key: 's'},
                    {ctrl: true, key: 'p'},
                    {cmd: true, key: 'c'}, // Mac
                    {cmd: true, key: 'v'}, // Mac
                    {cmd: true, key: 'x'}, // Mac
                    {cmd: true, key: 'a'}, // Mac
                    {cmd: true, key: 's'}, // Mac
                    {cmd: true, key: 'p'}, // Mac

                    // View Source
                    {ctrl: true, key: 'u'},
                    {ctrl: true, key: 'U'},
                    {cmd: true, key: 'u'}, // Mac

                    // Zoom
                    {ctrl: true, key: '+'},
                    {ctrl: true, key: '-'},
                    {ctrl: true, key: '0'},
                    {cmd: true, key: '+'}, // Mac
                    {cmd: true, key: '-'}, // Mac
                    {cmd: true, key: '0'}, // Mac

                    // Alt+Tab
                    {alt: true, key: 'Tab'},
                    {cmd: true, key: 'Tab'}, // Mac

                    // Find
                    {ctrl: true, key: 'f'},
                    {ctrl: true, key: 'g'},
                    {cmd: true, key: 'f'}, // Mac
                    {cmd: true, key: 'g'}, // Mac

                    // All function keys
                    {key: 'F1'}, {key: 'F2'}, {key: 'F3'}, {key: 'F4'},
                    {key: 'F5'}, {key: 'F6'}, {key: 'F7'}, {key: 'F8'},
                    {key: 'F9'}, {key: 'F10'}, {key: 'F11'}, {key: 'F12'}
                ];

                const isBlocked = blockedCombinations.some(combo => {
                    return Object.keys(combo).every(key => {
                        switch(key) {
                            case 'key': return e.key === combo.key || e.code === combo.key;
                            case 'ctrl': return e.ctrlKey === combo.ctrl;
                            case 'shift': return e.shiftKey === combo.shift;
                            case 'alt': return e.altKey === combo.alt;
                            case 'cmd': return e.metaKey === combo.cmd;
                            default: return true;
                        }
                    });
                });

                if (isBlocked) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    this.recordViolation('keyboard_shortcut', `Blocked key combination: ${e.key}`);
                    return false;
                }
            }, true);
        }

        blockContextMenu() {
            ['contextmenu', 'selectstart', 'dragstart'].forEach(event => {
                document.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (event === 'contextmenu') {
                        this.recordViolation('right_click', 'Right-click attempted');
                    }
                    return false;
                }, true);
            });
        }

        blockTextSelection() {
            document.addEventListener('selectstart', (e) => {
                if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    e.preventDefault();
                    return false;
                }
            });
        }

        blockDragDrop() {
            ['drag', 'dragend', 'dragenter', 'dragover', 'dragstart', 'drop'].forEach(event => {
                document.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }, true);
            });
        }

        detectDevTools() {
            // Multiple detection methods
            setInterval(() => {
                // Method 1: Console detection
                let devtools = {open: false, orientation: null};
                setInterval(() => {
                    if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
                        if (!devtools.open) {
                            devtools.open = true;
                            this.recordViolation('dev_tools', 'Developer tools detected (size method)');
                        }
                    } else {
                        devtools.open = false;
                    }
                }, 500);

                // Method 2: Console.clear detection
                const originalClear = console.clear;
                console.clear = () => {
                    this.recordViolation('dev_tools', 'Console.clear() detected');
                    return originalClear.apply(console, arguments);
                };

                // Method 3: Debug detection
                let startTime = performance.now();
                debugger;
                let endTime = performance.now();
                if (endTime - startTime > 100) {
                    this.recordViolation('dev_tools', 'Debugger statement detected');
                }
            }, 1000);
        }

        preventConsoleAccess() {
            // Override console methods
            const noop = () => {};
            const consoleProps = ['log', 'debug', 'info', 'warn', 'error', 'table', 'trace', 'dir', 'dirxml', 'group', 'groupCollapsed', 'groupEnd', 'clear', 'count', 'countReset', 'assert', 'profile', 'profileEnd', 'time', 'timeLog', 'timeEnd', 'timeStamp'];

            consoleProps.forEach(prop => {
                try {
                    Object.defineProperty(console, prop, {
                        get: () => {
                            this.recordViolation('console_access', `Console.${prop} accessed`);
                            return noop;
                        },
                        set: noop
                    });
                } catch (e) {}
            });
        }

        overrideConsoleMethods() {
            // Additional console protection
            if (typeof console !== 'undefined') {
                Object.defineProperty(window, 'console', {
                    get: () => {
                        this.recordViolation('console_access', 'Console object accessed');
                        return {};
                    },
                    set: () => {}
                });
            }
        }

        monitorPageVisibility() {
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this.recordViolation('tab_switch', 'Page became hidden');
                    decrementAttempts(true);
                }
            });

            window.addEventListener('blur', () => {
                this.recordViolation('window_blur', 'Window lost focus');
                decrementAttempts(true);
            });

            window.addEventListener('focus', () => {
                this.lastActivityTime = Date.now();
            });
        }

        preventDebugging() {
            // Infinite debugger loop
            setInterval(() => {
                function detectDebugger() {
                    const start = new Date();
                    debugger;
                    const end = new Date();
                    if (end - start > 100) {
                        this.recordViolation('debugger_detected', 'Debugger execution detected');
                    }
                }
                detectDebugger.call(this);
            }, 1000);

            // Prevent step debugging
            (() => {
                function block() {
                    setInterval(() => {
                        (function() {
                            return false;
                        })['constructor']('debugger')['call']();
                    }, 50);
                }
                try {
                    block();
                } catch (e) {}
            })();
        }

        blockViewSource() {
            // Prevent view source
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'u') {
                    e.preventDefault();
                    this.recordViolation('view_source', 'View source attempted');
                    return false;
                }
            });
        }

        enterFullscreen() {
            // Try to enter fullscreen mode
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }

            // Monitor fullscreen exit
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    this.recordViolation('fullscreen_exit', 'Exited fullscreen mode');
                }
            });
        }

        startSecurityChecks() {
            this.securityCheckInterval = setInterval(() => {
                // Check for automation tools
                if (window.navigator.webdriver) {
                    this.recordViolation('automation', 'WebDriver detected');
                }

                // Check for suspicious properties
                if (window.chrome && window.chrome.runtime && window.chrome.runtime.onConnect) {
                    this.recordViolation('extension', 'Chrome extension detected');
                }

                // Check activity
                if (Date.now() - this.lastActivityTime > 300000) { // 5 minutes
                    this.recordViolation('inactivity', 'No activity for 5 minutes');
                }

                // Check window size (potential dev tools)
                if (window.outerHeight - window.innerHeight > 200) {
                    this.recordViolation('window_size', 'Suspicious window dimensions');
                }
            }, 5000);
        }

        recordViolation(type, message) {
            this.violations++;
            console.log(`Security violation #${this.violations}: ${type} - ${message}`);

            // Update modal
            document.getElementById('violationCount').textContent = this.violations;
            document.getElementById('securityMessage').textContent = `${message} (Type: ${type})`;

            // Show warning modal
            const modal = new bootstrap.Modal(document.getElementById('securityWarningModal'));
            modal.show();

            // Auto-submit if max violations reached
            if (this.violations >= this.maxViolations) {
                setTimeout(() => {
                    alert('Maximum security violations reached. Test will be automatically submitted.');
                    submitForm();
                }, 2000);
            }
        }
    }

    // Initialize variables
    let timeRemaining = @Model.Test.TimeLimit * 60;
    const timerElement = document.getElementById('timer');
    const progressBar = document.getElementById('progressBar');
    const currentQuestionNumber = document.getElementById('currentQuestionNumber');
    const totalQuestions = document.getElementById('totalQuestions');
    const questionTypeBadge = document.getElementById('questionTypeBadge');
    let formSubmitted = false;
    let remainingAttempts = parseInt(document.getElementById('remainingAttempts').value);
    const attemptId = document.getElementById('AttemptId').value;
    const modal = new bootstrap.Modal(document.getElementById('attemptWarningModal'));
    const submitModal = new bootstrap.Modal(document.getElementById('submitConfirmModal'));

    // Initialize anti-cheat system
    const antiCheat = new EnhancedAntiCheat();

    // Question navigation
    const questionContainers = document.querySelectorAll('.question-container');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const questionNavBtns = document.querySelectorAll('.question-nav-btn');
    let currentQuestionIndex = 0;

    // Track answered questions
    const questionStatus = new Array(questionContainers.length).fill(false);

    // Security warning acknowledgment
    function acknowledgeWarning() {
        const warningModal = bootstrap.Modal.getInstance(document.getElementById('securityWarningModal'));
        warningModal.hide();
    }

    // Timer logic
    function updateTimer() {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        // Change color based on time remaining
        if (timeRemaining <= 300) { // 5 minutes
            timerElement.classList.remove('bg-primary');
            timerElement.classList.add('bg-warning');
        }

        if (timeRemaining <= 120) { // 2 minutes
            timerElement.classList.remove('bg-warning');
            timerElement.classList.add('bg-danger', 'animate-pulse');
        }

        if (timeRemaining <= 0) {
            submitForm();
        } else {
            timeRemaining--;
        }
    }

    // Start timer
    let timerInterval;
    if (timeRemaining > 0) {
        timerInterval = setInterval(updateTimer, 1000);
    }

    // Form submission handler
    function submitForm() {
        if (formSubmitted) return;
        formSubmitted = true;
        clearInterval(timerInterval);
        if (antiCheat.securityCheckInterval) {
            clearInterval(antiCheat.securityCheckInterval);
        }
        document.getElementById('testForm').submit();
    }

    // Show question
    function showQuestion(index) {
        // Hide all questions
        questionContainers.forEach(container => container.style.display = 'none');

        // Show the current question
        questionContainers[index].style.display = 'block';

        // Update navigation buttons
        prevBtn.disabled = index === 0;
        nextBtn.style.display = index === questionContainers.length - 1 ? 'none' : 'block';
        submitBtn.style.display = index === questionContainers.length - 1 ? 'block' : 'none';

        // Update progress indicator
        currentQuestionNumber.textContent = index + 1;
        progressBar.style.width = `${((index + 1) / questionContainers.length) * 100}%`;
        progressBar.setAttribute('aria-valuenow', ((index + 1) / questionContainers.length) * 100);

        // Update question type badge
        const questionType = questionContainers[index].dataset.questionType;
        let badgeClass = 'bg-primary';
        let icon = '';

        switch(questionType) {
            case 'MultipleChoice':
                badgeClass = 'bg-primary';
                icon = 'list-ul';
                break;
            case 'TrueFalse':
                badgeClass = 'bg-success';
                icon = 'check-circle';
                break;
            case 'ShortAnswer':
                badgeClass = 'bg-info';
                icon = 'pen';
                break;
        }

        questionTypeBadge.className = `badge ${badgeClass}`;
        questionTypeBadge.innerHTML = `<i class="fas fa-${icon} me-1"></i>${questionType.replace(/([A-Z])/g, ' $1').trim()}`;

        // Update question navigation
        questionNavBtns.forEach(btn => {
            btn.classList.remove('active', 'btn-primary', 'btn-outline-secondary', 'btn-success');

            const btnIndex = parseInt(btn.dataset.questionIndex);
            if (btnIndex === index) {
                btn.classList.add('active', 'btn-primary');
            } else if (questionStatus[btnIndex]) {
                btn.classList.add('btn-success');
            } else {
                btn.classList.add('btn-outline-secondary');
            }
        });

        // Set current index
        currentQuestionIndex = index;
    }

    // Go to specific question
    function goToQuestion(index) {
        showQuestion(index);
    }

    // Navigation button handlers
    prevBtn.addEventListener('click', () => {
        if (currentQuestionIndex > 0) {
            showQuestion(currentQuestionIndex - 1);
        }
    });

    nextBtn.addEventListener('click', () => {
        if (currentQuestionIndex < questionContainers.length - 1) {
            showQuestion(currentQuestionIndex + 1);
        }
    });

    // Monitor answer changes
    function updateQuestionStatus() {
        questionContainers.forEach((container, index) => {
            const questionType = container.dataset.questionType;
            let isAnswered = false;

            switch(questionType) {
                case 'MultipleChoice':
                    const mcOptions = container.querySelectorAll('input[type="radio"], input[type="checkbox"]');
                    isAnswered = Array.from(mcOptions).some(option => option.checked);
                    break;
                case 'TrueFalse':
                    const tfOptions = container.querySelectorAll('input[type="radio"]');
                    isAnswered = Array.from(tfOptions).some(option => option.checked);
                    break;
                case 'ShortAnswer':
                    const saInput = container.querySelector('input[type="text"]');
                    isAnswered = saInput && saInput.value.trim() !== '';
                    break;
            }

            questionStatus[index] = isAnswered;

            // Update navigation button
            const navBtn = document.querySelector(`.question-nav-btn[data-question-index="${index}"]`);
            if (navBtn) {
                navBtn.classList.remove('btn-success', 'btn-outline-secondary');
                navBtn.classList.add(isAnswered ? 'btn-success' : 'btn-outline-secondary');
            }
        });
    }

    // Listen for input changes
    document.querySelectorAll('input[type="radio"], input[type="checkbox"], input[type="text"]').forEach(input => {
        input.addEventListener('change', updateQuestionStatus);

        // For text inputs, listen for keyup as well
        if (input.type === 'text') {
            input.addEventListener('keyup', updateQuestionStatus);
        }
    });

    // Submit button handler
    submitBtn.addEventListener('click', (e) => {
        e.preventDefault();

        // Count unanswered questions
        const unansweredCount = questionStatus.filter(status => !status).length;

        const unansweredWarning = document.getElementById('unansweredWarning');
        const unansweredCountElement = document.getElementById('unansweredCount');

        if (unansweredCount > 0) {
            unansweredWarning.style.display = 'block';
            unansweredCountElement.textContent = unansweredCount;
        } else {
            unansweredWarning.style.display = 'none';
        }

        // Show the confirmation modal
        submitModal.show();
    });

    // Confirm submit handler
    document.getElementById('confirmSubmitBtn').addEventListener('click', () => {
        submitForm();
    });

    // Flag to prevent multiple decrements
    let isAttemptDecremented = false;

    // Decrement attempts with modal notification
    async function decrementAttempts(showWarning = true) {
        if (remainingAttempts <= 0 || isAttemptDecremented) return;

        isAttemptDecremented = true; // Set flag to prevent multiple calls
        remainingAttempts--;
        document.getElementById('remainingAttempts').value = remainingAttempts;
        document.getElementById('remainingAttemptsCounter').textContent = remainingAttempts;
        document.getElementById('modalRemainingAttemptsCounter').textContent = remainingAttempts;

        try {
            const response = await fetch('/TestAttempt/UpdateRemainingAttempts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ attemptId, remainingAttempts })
            });

            if (!response.ok) throw new Error('Failed to update attempts');

            if (remainingAttempts <= 0) {
                submitForm();
            } else if (showWarning) {
                modal.show();
            }
        } catch (error) {
            console.error('Error:', error);
            remainingAttempts++; // Rollback on error
            document.getElementById('remainingAttemptsCounter').textContent = remainingAttempts;
        } finally {
            // Reset the flag after a short delay to allow future decrements
            setTimeout(() => {
                isAttemptDecremented = false;
            }, 1000); // 1-second delay
        }
    }

    // Enhanced visibility detection
    function handleVisibilityChange() {
        if (document.visibilityState === 'hidden') {
            decrementAttempts(true);
        }
    }

    // Enhanced focus/blur detection
    function handleFocusChange() {
        if (!document.hasFocus()) {
            decrementAttempts(true);
        }
    }

    // Attach event listeners
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('blur', handleFocusChange);
    window.addEventListener('focus', () => {
        antiCheat.lastActivityTime = Date.now();
    });

    // Navigation/closing detection
    window.addEventListener('beforeunload', (e) => {
        if (!formSubmitted) {
            e.preventDefault();
            e.returnValue = 'Are you sure you want to leave? Your remaining attempts will be decremented.';
            decrementAttempts(false);
        }
    });

    // Additional security measures
    document.addEventListener('paste', (e) => {
        if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
            e.preventDefault();
            antiCheat.recordViolation('paste_blocked', 'Paste operation blocked');
        }
    });

    // Prevent print screen
    document.addEventListener('keyup', (e) => {
        if (e.key === 'PrintScreen') {
            antiCheat.recordViolation('print_screen', 'Print Screen key detected');
        }
    });

    // Monitor mouse activity for automation detection
    let mouseEvents = 0;
    document.addEventListener('mousemove', () => {
        mouseEvents++;
        antiCheat.lastActivityTime = Date.now();
    });

    // Check for unusual mouse patterns
    setInterval(() => {
        if (mouseEvents === 0) {
            antiCheat.recordViolation('no_mouse_activity', 'No mouse movement detected');
        }
        mouseEvents = 0;
    }, 30000); // Check every 30 seconds

    // Prevent iframe injection
    if (window.self !== window.top) {
        antiCheat.recordViolation('iframe_detected', 'Page loaded in iframe');
        window.top.location = window.self.location;
    }

    // Check for headless browser
    if (navigator.webdriver || window.navigator.webdriver) {
        antiCheat.recordViolation('webdriver_detected', 'WebDriver detected');
    }

    // Check for common automation properties
    if (window.phantom || window._phantom || window.callPhantom) {
        antiCheat.recordViolation('phantom_detected', 'PhantomJS detected');
    }

    if (window.Buffer) {
        antiCheat.recordViolation('nodejs_detected', 'Node.js Buffer detected');
    }

    // Additional automation checks
    if (window.spawn || window.emit) {
        antiCheat.recordViolation('automation_detected', 'Automation tools detected');
    }

    // Initialize - show the first question
    showQuestion(0);
    updateQuestionStatus();

    // Add keyboard navigation
    document.addEventListener('keydown', (e) => {
        // Only respond to arrow keys if not in an input field
        if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
            return;
        }

        if (e.key === 'ArrowLeft' && currentQuestionIndex > 0) {
            showQuestion(currentQuestionIndex - 1);
        } else if (e.key === 'ArrowRight' && currentQuestionIndex < questionContainers.length - 1) {
            showQuestion(currentQuestionIndex + 1);
        }
    });

    // Custom radio/checkbox styling
    document.querySelectorAll('.custom-option').forEach(option => {
        option.addEventListener('click', function(e) {
            if (e.target.tagName !== 'INPUT') {
                const input = this.querySelector('input');
                input.checked = !input.checked;

                // Trigger change event for tracking answered status
                const event = new Event('change');
                input.dispatchEvent(event);
            }
        });
    });

    // Disable common browser shortcuts during test
    window.addEventListener('keydown', (e) => {
        // Block Ctrl+W (close tab)
        if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
            e.preventDefault();
            antiCheat.recordViolation('close_tab_attempt', 'Attempted to close tab');
        }

        // Block Ctrl+T (new tab)
        if ((e.ctrlKey || e.metaKey) && e.key === 't') {
            e.preventDefault();
            antiCheat.recordViolation('new_tab_attempt', 'Attempted to open new tab');
        }

        // Block Ctrl+N (new window)
        if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
            e.preventDefault();
            antiCheat.recordViolation('new_window_attempt', 'Attempted to open new window');
        }

        // Block Ctrl+Shift+T (restore tab)
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 't') {
            e.preventDefault();
            antiCheat.recordViolation('restore_tab_attempt', 'Attempted to restore tab');
        }
    }, true);

    // Detect if running in headless mode
    if (window.outerWidth === 0 && window.outerHeight === 0) {
        antiCheat.recordViolation('headless_detected', 'Headless browser detected');
    }

    // Check for missing browser features (indicates automation)
    if (!window.chrome || !window.chrome.runtime) {
        // This might be a normal browser, but combined with other factors could indicate automation
    }

    // Monitor for suspicious console activity
    let consoleCallCount = 0;
    const originalLog = console.log;
    console.log = function(...args) {
        consoleCallCount++;
        if (consoleCallCount > 10) {
            antiCheat.recordViolation('excessive_console', 'Excessive console usage detected');
        }
        return originalLog.apply(console, args);
    };

    // Final security check on page load
    setTimeout(() => {
        if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
            antiCheat.recordViolation('dev_tools_open', 'Developer tools appear to be open on load');
        }
    }, 2000);

    // Lock the page in fullscreen if possible
    function requestFullscreen() {
        const element = document.documentElement;
        if (element.requestFullscreen) {
            element.requestFullscreen().catch(() => {});
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    }

    // Request fullscreen after user interaction
    document.addEventListener('click', requestFullscreen, { once: true });
    document.addEventListener('keydown', requestFullscreen, { once: true });

    // Prevent back button
    history.pushState(null, null, location.href);
    window.addEventListener('popstate', () => {
        history.go(1);
        antiCheat.recordViolation('back_button', 'Back button usage detected');
    });
</script>
}