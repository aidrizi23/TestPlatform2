@model TestPlatform2.Models.TakeTestViewModel
@using Microsoft.AspNetCore.Mvc.TagHelpers
@using TestPlatform2.Data.Questions
@using TestPlatform2.Models

@{
ViewData["Title"] = "Taking Test: " + Model.Test.TestName;
}

<div class="test-taking-container">
    <!-- Modern Test Header -->
    <div class="test-header">
        <div class="test-header-content">
            <div class="test-info">
                <h1 class="test-title">
                    <i class="fas fa-clipboard-check me-3"></i>
                    @Model.Test.TestName
                </h1>
                @if (!string.IsNullOrEmpty(Model.Test.Description))
                {
                    <p class="test-description">@Model.Test.Description</p>
                }
            </div>
            
            <div class="test-controls">
                <div class="timer-widget">
                    <div class="timer-icon">
                        <i class="fas fa-clock"></i>
                    </div>
                    <div class="timer-content">
                        <div class="timer-label">Time Remaining</div>
                        <div id="timer" class="timer-display">@($"{Model.Test.TimeLimit:00}:00")</div>
                    </div>
                </div>
                
                <div class="attempts-widget">
                    <div class="attempts-icon">
                        <i class="fas fa-redo"></i>
                    </div>
                    <div class="attempts-content">
                        <div class="attempts-label">Attempts Left</div>
                        <div id="remainingAttemptsCounter" class="attempts-display">@Model.RemainingAttempts</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Progress Section -->
        <div class="progress-section">
            <div class="progress-info">
                <span class="question-counter">
                    Question <span id="currentQuestionNumber">1</span> of <span id="totalQuestions">@Model.Questions.Count</span>
                </span>
                <span id="questionTypeBadge" class="question-type-badge"></span>
            </div>
            <div class="progress-bar-container">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Test Form -->
    <form id="testForm" asp-action="SubmitAnswers" method="post">
        <input type="hidden" asp-for="AttemptId" />
        <input type="hidden" id="remainingAttempts" value="@Model.RemainingAttempts" />

        @if (Model.Questions != null && Model.Questions.Any())
        {
        <!-- Question Container -->
        <div class="question-widget">
            @for (int i = 0; i < Model.Questions.Count; i++)
            {
            var question = Model.Questions[i];
            <div class="question-container" data-question-index="@i" data-question-type="@question.GetType().Name.Replace("Question", "")" style="display: none;">
                <div class="question-card">
                    <div class="question-header">
                        <div class="question-meta">
                            <span class="question-number">Question @(i + 1)</span>
                            <span class="question-points">@question.Points pts</span>
                        </div>
                        <div class="question-text">
                            <h3>@question.Text</h3>
                        </div>
                    </div>
                    
                    <div class="question-content">
                        <input type="hidden" name="answers[@i].QuestionId" value="@question.Id" />

                        @switch (question)
                        {
                        case MultipleChoiceQuestion mcq:
                        <div class="answer-section multiple-choice-section">
                            @if (mcq.AllowMultipleSelections)
                            {
                            <div class="selection-hint">
                                <i class="fas fa-check-double me-2"></i>
                                Multiple selections allowed
                            </div>
                            }
                            
                            <div class="options-grid">
                                @for (int j = 0; j < mcq.Options.Count; j++)
                                {
                                <div class="option-card">
                                    <input class="option-input" type="@(mcq.AllowMultipleSelections ? "checkbox" : "radio")"
                                           name="answers[@i].Response" id="option-@i-@j" value="@mcq.Options[j]"
                                           data-question-index="@i" />
                                    <label class="option-label" for="option-@i-@j">
                                        <div class="option-indicator">
                                            <i class="fas fa-@(mcq.AllowMultipleSelections ? "check-square" : "circle")"></i>
                                        </div>
                                        <div class="option-text">@mcq.Options[j]</div>
                                    </label>
                                </div>
                                }
                            </div>
                        </div>
                        break;

                        case TrueFalseQuestion:
                        <div class="answer-section true-false-section">
                            <div class="true-false-grid">
                                <div class="tf-option tf-true">
                                    <input class="tf-input" type="radio" name="answers[@i].Response"
                                           id="true-@i" value="True" data-question-index="@i" />
                                    <label class="tf-label" for="true-@i">
                                        <div class="tf-icon">
                                            <i class="fas fa-check"></i>
                                        </div>
                                        <div class="tf-text">True</div>
                                    </label>
                                </div>
                                <div class="tf-option tf-false">
                                    <input class="tf-input" type="radio" name="answers[@i].Response"
                                           id="false-@i" value="False" data-question-index="@i" />
                                    <label class="tf-label" for="false-@i">
                                        <div class="tf-icon">
                                            <i class="fas fa-times"></i>
                                        </div>
                                        <div class="tf-text">False</div>
                                    </label>
                                </div>
                            </div>
                        </div>
                        break;

                        case ShortAnswerQuestion:
                        <div class="answer-section short-answer-section">
                            <div class="answer-input-container">
                                <div class="input-wrapper">
                                    <i class="fas fa-pen input-icon"></i>
                                    <input class="answer-input" type="text" name="answers[@i].Response"
                                           placeholder="Type your answer here..." autocomplete="off"
                                           data-question-index="@i" />
                                </div>
                                <div class="input-hint">
                                    <i class="fas fa-lightbulb me-2"></i>
                                    Be precise and check your spelling carefully
                                </div>
                            </div>
                        </div>
                        break;




                        default:
                        <div class="answer-section unsupported-section">
                            <div class="alert alert-warning">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                This question type is not supported in the current test interface.
                            </div>
                        </div>
                        break;
                        }
                    </div>
                </div>
            </div>
            }
        </div>

        <!-- Navigation Controls -->
        <div class="navigation-controls">
            <button type="button" id="prevBtn" class="nav-btn nav-btn-prev">
                <i class="fas fa-chevron-left"></i>
                <span>Previous</span>
            </button>

            <div class="nav-actions">
                <button type="button" id="nextBtn" class="nav-btn nav-btn-next">
                    <span>Next</span>
                    <i class="fas fa-chevron-right"></i>
                </button>
                <button type="submit" id="submitBtn" class="nav-btn nav-btn-submit" style="display: none;">
                    <i class="fas fa-paper-plane me-2"></i>
                    <span>Submit Test</span>
                </button>
            </div>
        </div>
        }
        else
        {
        <div class="alert alert-danger">
            <i class="fas fa-exclamation-triangle me-2"></i>
            No questions available for this test.
        </div>
        }
    </form>

    <!-- Question Navigation -->
    <div class="question-navigation-widget">
        <div class="nav-header">
            <div class="nav-title">
                <i class="fas fa-list-ol me-2"></i>
                <span>Question Navigator</span>
            </div>
            <div class="nav-legend">
                <div class="legend-item">
                    <div class="legend-dot answered"></div>
                    <span>Answered</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot current"></div>
                    <span>Current</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot unanswered"></div>
                    <span>Unanswered</span>
                </div>
            </div>
        </div>
        <div class="nav-grid">
            @for (int i = 0; i < Model.Questions.Count; i++)
            {
            <button type="button" class="question-nav-item"
                    data-question-index="@i" onclick="goToQuestion(@i)">
                <span class="nav-number">@(i + 1)</span>
            </button>
            }
        </div>
    </div>
</div>

<!-- Security Warning Modal -->
<div class="modal fade" id="securityWarningModal" tabindex="-1" aria-labelledby="securityWarningLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-danger">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title" id="securityWarningLabel">
                    <i class="fas fa-shield-alt me-2"></i>Security Violation Detected
                </h5>
            </div>
            <div class="modal-body text-center">
                <i class="fas fa-exclamation-triangle fa-3x text-danger mb-3"></i>
                <h4>Unauthorized Activity Detected!</h4>
                <p id="securityMessage" class="mb-3">You have attempted to use prohibited tools or actions during the test.</p>
                <div class="alert alert-warning">
                    <strong>Warning:</strong> Continued violations will result in automatic test submission and account restrictions.
                </div>
                <p><strong>Violations: <span id="violationCount">0</span>/3</strong></p>
            </div>
            <div class="modal-footer justify-content-center">
                <button type="button" class="btn btn-primary" onclick="acknowledgeWarning()">
                    <i class="fas fa-check me-2"></i>I Understand - Continue Test
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Attempt Warning Modal -->
<div class="modal fade" id="attemptWarningModal" tabindex="-1" aria-labelledby="attemptWarningLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning">
                <h5 class="modal-title" id="attemptWarningLabel">
                    <i class="fas fa-exclamation-triangle me-2"></i>Warning!
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>You have <strong id="modalRemainingAttemptsCounter">@Model.RemainingAttempts</strong> attempt(s) remaining.</p>
                <p class="text-danger">
                    <i class="fas fa-exclamation-circle me-2"></i>
                    Leaving the page or using restricted features will reduce your remaining attempts.
                </p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">
                    <i class="fas fa-check-circle me-2"></i>Continue Test
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Submission Confirmation Modal -->
<div class="modal fade" id="submitConfirmModal" tabindex="-1" aria-labelledby="submitConfirmLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="submitConfirmLabel">
                    <i class="fas fa-question-circle me-2"></i>Confirm Submission
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to submit your test?</p>
                <div id="unansweredWarning" class="alert alert-warning" style="display: none;">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    You have <strong id="unansweredCount">0</strong> unanswered questions!
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="fas fa-times me-2"></i>Continue Test
                </button>
                <button type="button" class="btn btn-success" id="confirmSubmitBtn">
                    <i class="fas fa-check-circle me-2"></i>Submit Test
                </button>
            </div>
        </div>
    </div>
</div>

<style>
    /* Enhanced security styles */
    body {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
    }

    .container {
        pointer-events: auto;
    }

    /* Prevent text highlighting */
    * {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
    }

    /* Allow input fields to be selectable */
    input, textarea, select {
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
    }

    /* Hide scrollbars to prevent right-click */
    ::-webkit-scrollbar {
        width: 0px;
        background: transparent;
    }

    /* Security overlay for dev tools detection */
    .security-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(220, 38, 38, 0.95);
        z-index: 10000;
        display: none;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 2rem;
        text-align: center;
    }

    /* Fullscreen test mode */
    .test-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        background: white !important;
        overflow-y: auto !important;
    }

    /* Modern Test Taking Styles */
    .test-taking-container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 2rem;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        min-height: 100vh;
    }

    /* Test Header Styles */
    .test-header {
        background: #fff;
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .test-header-content {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 1.5rem;
    }

    .test-info .test-title {
        font-size: 2rem;
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
    }

    .test-info .test-description {
        color: #6c757d;
        font-size: 1.1rem;
        margin: 0;
    }

    .test-controls {
        display: flex;
        gap: 1.5rem;
    }

    /* Widget Styles */
    .timer-widget, .attempts-widget {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 15px;
        padding: 1rem 1.5rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        min-width: 180px;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }

    .attempts-widget {
        background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        color: #8b4513;
        box-shadow: 0 8px 25px rgba(252, 182, 159, 0.3);
    }

    .timer-icon, .attempts-icon {
        font-size: 1.5rem;
        opacity: 0.9;
    }

    .timer-content, .attempts-content {
        flex: 1;
    }

    .timer-label, .attempts-label {
        font-size: 0.85rem;
        opacity: 0.9;
        font-weight: 500;
        margin-bottom: 0.25rem;
    }

    .timer-display, .attempts-display {
        font-size: 1.3rem;
        font-weight: 700;
        font-family: 'Courier New', monospace;
    }

    /* Progress Section */
    .progress-section {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 2rem;
    }

    .progress-info {
        display: flex;
        align-items: center;
        gap: 1rem;
    }

    .question-counter {
        font-weight: 600;
        color: #495057;
        font-size: 1.1rem;
    }

    .question-type-badge {
        font-size: 0.85rem;
        padding: 0.4rem 0.8rem;
        border-radius: 20px;
        font-weight: 600;
    }

    .progress-bar-container {
        flex: 1;
        height: 8px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 4px;
        overflow: hidden;
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    /* Question Widget */
    .question-widget {
        margin-bottom: 2rem;
    }

    .question-card {
        background: #fff;
        border-radius: 20px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .question-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 2rem;
    }

    .question-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        font-size: 0.9rem;
        opacity: 0.9;
    }

    .question-number {
        font-weight: 600;
    }

    .question-points {
        background: rgba(255, 255, 255, 0.2);
        padding: 0.3rem 0.8rem;
        border-radius: 15px;
        font-weight: 600;
    }

    .question-text h3 {
        margin: 0;
        font-size: 1.4rem;
        font-weight: 600;
        line-height: 1.4;
    }

    .question-content {
        padding: 2rem;
    }

    /* Answer Sections */
    .answer-section {
        margin-top: 1.5rem;
    }

    /* Multiple Choice Styles */
    .selection-hint {
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        color: #1976d2;
        padding: 0.8rem 1rem;
        border-radius: 10px;
        margin-bottom: 1.5rem;
        font-weight: 500;
        font-size: 0.9rem;
    }

    .options-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: 1fr;
    }

    .option-card {
        position: relative;
    }

    .option-input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
    }

    .option-label {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1.2rem;
        background: #f8f9fa;
        border: 2px solid #e9ecef;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
    }

    .option-label:hover {
        background: #e3f2fd;
        border-color: #2196f3;
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(33, 150, 243, 0.2);
    }

    .option-input:checked + .option-label {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        color: white;
        border-color: #1976d2;
        box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
    }

    .option-indicator {
        font-size: 1.2rem;
        opacity: 0.7;
    }

    .option-input:checked + .option-label .option-indicator {
        opacity: 1;
    }

    .option-text {
        flex: 1;
        font-size: 1rem;
    }

    /* True/False Styles */
    .true-false-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
        margin-top: 1rem;
    }

    .tf-option {
        position: relative;
    }

    .tf-input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
    }

    .tf-label {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        padding: 2rem 1rem;
        background: #f8f9fa;
        border: 3px solid #e9ecef;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    }

    .tf-true .tf-label:hover {
        background: #e8f5e8;
        border-color: #4caf50;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(76, 175, 80, 0.2);
    }

    .tf-false .tf-label:hover {
        background: #ffebee;
        border-color: #f44336;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(244, 67, 54, 0.2);
    }

    .tf-true .tf-input:checked + .tf-label {
        background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        color: white;
        border-color: #388e3c;
        box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
    }

    .tf-false .tf-input:checked + .tf-label {
        background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        color: white;
        border-color: #d32f2f;
        box-shadow: 0 8px 25px rgba(244, 67, 54, 0.4);
    }

    .tf-icon {
        font-size: 2.5rem;
        opacity: 0.8;
    }

    .tf-input:checked + .tf-label .tf-icon {
        opacity: 1;
    }

    .tf-text {
        font-size: 1.2rem;
        font-weight: 600;
    }

    /* Short Answer Styles */
    .answer-input-container {
        margin-top: 1rem;
    }

    .input-wrapper {
        position: relative;
        margin-bottom: 1rem;
    }

    .input-icon {
        position: absolute;
        left: 1rem;
        top: 50%;
        transform: translateY(-50%);
        color: #6c757d;
        font-size: 1rem;
        z-index: 2;
    }

    .answer-input {
        width: 100%;
        padding: 1rem 1rem 1rem 3rem;
        border: 2px solid #e9ecef;
        border-radius: 12px;
        font-size: 1rem;
        transition: all 0.2s ease;
        background: #f8f9fa;
    }

    .answer-input:focus {
        outline: none;
        border-color: #2196f3;
        background: white;
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }

    .input-hint {
        color: #6c757d;
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
        background: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
    }

    /* Navigation Controls */
    .navigation-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 2rem 0;
        padding: 1.5rem 2rem;
        background: #fff;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }

    .nav-btn {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.8rem 1.5rem;
        border: none;
        border-radius: 10px;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .nav-btn-prev {
        background: #6c757d;
        color: white;
    }

    .nav-btn-prev:hover:not(:disabled) {
        background: #5a6268;
        transform: translateX(-2px);
    }

    .nav-btn-prev:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .nav-btn-next {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        color: white;
    }

    .nav-btn-next:hover {
        background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
        transform: translateX(2px);
        box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
    }

    .nav-btn-submit {
        background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        color: white;
    }

    .nav-btn-submit:hover {
        background: linear-gradient(135deg, #388e3c 0%, #2e7d32 100%);
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    }

    .nav-actions {
        display: flex;
        gap: 1rem;
    }

    /* Question Navigation Widget */
    .question-navigation-widget {
        background: #fff;
        border-radius: 20px;
        padding: 2rem;
        margin-top: 2rem;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
    }

    .nav-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #f1f3f4;
    }

    .nav-title {
        display: flex;
        align-items: center;
        font-size: 1.2rem;
        font-weight: 600;
        color: #2c3e50;
    }

    .nav-legend {
        display: flex;
        gap: 1.5rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: #6c757d;
    }

    .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
    }

    .legend-dot.answered {
        background: #4caf50;
    }

    .legend-dot.current {
        background: #2196f3;
    }

    .legend-dot.unanswered {
        background: #e0e0e0;
    }

    .nav-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
        gap: 0.8rem;
    }

    .question-nav-item {
        aspect-ratio: 1;
        border: 2px solid #e0e0e0;
        background: #f8f9fa;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 600;
        color: #6c757d;
    }

    .question-nav-item:hover {
        border-color: #2196f3;
        background: #e3f2fd;
        transform: translateY(-2px);
    }

    .question-nav-item.active {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        color: white;
        border-color: #1976d2;
    }

    .question-nav-item.btn-success {
        background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        color: white;
        border-color: #388e3c;
    }

    .nav-number {
        font-size: 1rem;
    }

    /* Table Question Styles */
    .table-title h5 {
        color: #2c3e50;
        font-weight: 600;
        margin-bottom: 1rem;
        text-align: center;
    }

    .table-container {
        margin-top: 1rem;
        overflow-x: auto;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .question-table {
        width: 100%;
        border-collapse: collapse;
        background: white;
        border-radius: 12px;
        overflow: hidden;
    }

    .question-table th {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        font-weight: 600;
        text-align: center;
        border: none;
    }

    .corner-cell {
        background: linear-gradient(135deg, #5a6fd8 0%, #6a3d9a 100%) !important;
    }

    .column-header, .row-header {
        font-size: 0.9rem;
        white-space: nowrap;
    }

    .table-cell {
        border: 2px solid #e9ecef;
        padding: 0;
        position: relative;
        transition: all 0.2s ease;
    }

    .table-cell:hover {
        border-color: #2196f3;
        background: #f8fafe;
    }

    .cell-content {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .table-cell-input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
        width: 100%;
        height: 100%;
        z-index: 2;
    }

    .cell-label {
        display: block;
        padding: 1rem;
        cursor: pointer;
        margin: 0;
        transition: all 0.2s ease;
        text-align: center;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .table-cell-input:checked + .cell-label {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        color: white;
        font-weight: 600;
    }

    .table-cell-input:hover + .cell-label {
        background: #e3f2fd;
        color: #1976d2;
    }

    .table-cell-input:checked:hover + .cell-label {
        background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
        color: white;
    }

    .cell-text {
        font-weight: 500;
        line-height: 1.4;
    }

    /* Responsive table */
    @@media (max-width: 768px) {
        .table-container {
            font-size: 0.9rem;
        }
        
        .cell-label {
            padding: 0.8rem;
            min-height: 50px;
        }
        
        .question-table th {
            padding: 0.8rem;
        }
    }

    /* Unsupported Question Type */
    .unsupported-section .alert {
        border-radius: 12px;
        border: none;
        padding: 1.5rem;
        font-weight: 500;
    }

    /* Responsive Design */
    @@media (max-width: 768px) {
        .test-taking-container {
            padding: 1rem;
        }
        
        .test-header-content {
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .test-controls {
            width: 100%;
            justify-content: space-between;
        }
        
        .timer-widget, .attempts-widget {
            min-width: auto;
            flex: 1;
        }
        
        .progress-section {
            flex-direction: column;
            gap: 1rem;
        }
        
        .true-false-grid {
            grid-template-columns: 1fr;
        }
        
        .navigation-controls {
            padding: 1rem;
        }
        
        .nav-legend {
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .nav-grid {
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
        }
    }
</style>

@section Scripts {
<script>
    // Enhanced Anti-Cheat System
    class EnhancedAntiCheat {
        constructor() {
            this.violations = 0;
            this.maxViolations = 3;
            this.isDevToolsOpen = false;
            this.securityCheckInterval = null;
            this.consoleWarnings = 0;
            this.lastActivityTime = Date.now();
            this.init();
        }

        init() {
            this.blockAllKeyboardShortcuts();
            this.blockContextMenu();
            this.blockTextSelection();
            this.blockDragDrop();
            this.detectDevTools();
            this.preventConsoleAccess();
            this.monitorPageVisibility();
            this.preventDebugging();
            this.blockViewSource();
            this.enterFullscreen();
            this.startSecurityChecks();
            this.overrideConsoleMethods();
        }

        blockAllKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                const blockedCombinations = [
                    // Dev Tools
                    {key: 'F12'},
                    {ctrl: true, shift: true, key: 'I'},
                    {ctrl: true, shift: true, key: 'J'},
                    {ctrl: true, shift: true, key: 'C'},
                    {cmd: true, alt: true, key: 'I'}, // Mac
                    {cmd: true, alt: true, key: 'J'}, // Mac
                    {cmd: true, alt: true, key: 'C'}, // Mac

                    // Refresh/Navigation
                    {key: 'F5'},
                    {ctrl: true, key: 'r'},
                    {ctrl: true, key: 'R'},
                    {cmd: true, key: 'r'}, // Mac
                    {alt: true, key: 'ArrowLeft'},
                    {alt: true, key: 'ArrowRight'},
                    {cmd: true, key: 'ArrowLeft'}, // Mac
                    {cmd: true, key: 'ArrowRight'}, // Mac

                    // Copy/Paste/Select/Save/Print
                    {ctrl: true, key: 'c'},
                    {ctrl: true, key: 'v'},
                    {ctrl: true, key: 'x'},
                    {ctrl: true, key: 'a'},
                    {ctrl: true, key: 's'},
                    {ctrl: true, key: 'p'},
                    {cmd: true, key: 'c'}, // Mac
                    {cmd: true, key: 'v'}, // Mac
                    {cmd: true, key: 'x'}, // Mac
                    {cmd: true, key: 'a'}, // Mac
                    {cmd: true, key: 's'}, // Mac
                    {cmd: true, key: 'p'}, // Mac

                    // View Source
                    {ctrl: true, key: 'u'},
                    {ctrl: true, key: 'U'},
                    {cmd: true, key: 'u'}, // Mac

                    // Zoom
                    {ctrl: true, key: '+'},
                    {ctrl: true, key: '-'},
                    {ctrl: true, key: '0'},
                    {cmd: true, key: '+'}, // Mac
                    {cmd: true, key: '-'}, // Mac
                    {cmd: true, key: '0'}, // Mac

                    // Alt+Tab
                    {alt: true, key: 'Tab'},
                    {cmd: true, key: 'Tab'}, // Mac

                    // Find
                    {ctrl: true, key: 'f'},
                    {ctrl: true, key: 'g'},
                    {cmd: true, key: 'f'}, // Mac
                    {cmd: true, key: 'g'}, // Mac

                    // All function keys
                    {key: 'F1'}, {key: 'F2'}, {key: 'F3'}, {key: 'F4'},
                    {key: 'F5'}, {key: 'F6'}, {key: 'F7'}, {key: 'F8'},
                    {key: 'F9'}, {key: 'F10'}, {key: 'F11'}, {key: 'F12'}
                ];

                const isBlocked = blockedCombinations.some(combo => {
                    return Object.keys(combo).every(key => {
                        switch(key) {
                            case 'key': return e.key === combo.key || e.code === combo.key;
                            case 'ctrl': return e.ctrlKey === combo.ctrl;
                            case 'shift': return e.shiftKey === combo.shift;
                            case 'alt': return e.altKey === combo.alt;
                            case 'cmd': return e.metaKey === combo.cmd;
                            default: return true;
                        }
                    });
                });

                if (isBlocked) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    this.recordViolation('keyboard_shortcut', `Blocked key combination: ${e.key}`);
                    return false;
                }
            }, true);
        }

        blockContextMenu() {
            ['contextmenu', 'selectstart', 'dragstart'].forEach(event => {
                document.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (event === 'contextmenu') {
                        this.recordViolation('right_click', 'Right-click attempted');
                    }
                    return false;
                }, true);
            });
        }

        blockTextSelection() {
            document.addEventListener('selectstart', (e) => {
                if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    e.preventDefault();
                    return false;
                }
            });
        }

        blockDragDrop() {
            ['drag', 'dragend', 'dragenter', 'dragover', 'dragstart', 'drop'].forEach(event => {
                document.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }, true);
            });
        }

        detectDevTools() {
            // Multiple detection methods
            setInterval(() => {
                // Method 1: Console detection
                let devtools = {open: false, orientation: null};
                setInterval(() => {
                    if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
                        if (!devtools.open) {
                            devtools.open = true;
                            this.recordViolation('dev_tools', 'Developer tools detected (size method)');
                        }
                    } else {
                        devtools.open = false;
                    }
                }, 500);

                // Method 2: Console.clear detection
                const originalClear = console.clear;
                console.clear = () => {
                    this.recordViolation('dev_tools', 'Console.clear() detected');
                    return originalClear.apply(console, arguments);
                };

                // Method 3: Debug detection
                let startTime = performance.now();
                debugger;
                let endTime = performance.now();
                if (endTime - startTime > 100) {
                    this.recordViolation('dev_tools', 'Debugger statement detected');
                }
            }, 1000);
        }

        preventConsoleAccess() {
            // Override console methods
            const noop = () => {};
            const consoleProps = ['log', 'debug', 'info', 'warn', 'error', 'table', 'trace', 'dir', 'dirxml', 'group', 'groupCollapsed', 'groupEnd', 'clear', 'count', 'countReset', 'assert', 'profile', 'profileEnd', 'time', 'timeLog', 'timeEnd', 'timeStamp'];

            consoleProps.forEach(prop => {
                try {
                    Object.defineProperty(console, prop, {
                        get: () => {
                            this.recordViolation('console_access', `Console.${prop} accessed`);
                            return noop;
                        },
                        set: noop
                    });
                } catch (e) {}
            });
        }

        overrideConsoleMethods() {
            // Additional console protection
            if (typeof console !== 'undefined') {
                Object.defineProperty(window, 'console', {
                    get: () => {
                        this.recordViolation('console_access', 'Console object accessed');
                        return {};
                    },
                    set: () => {}
                });
            }
        }

        monitorPageVisibility() {
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this.recordViolation('tab_switch', 'Page became hidden');
                    decrementAttempts(true);
                }
            });

            window.addEventListener('blur', () => {
                this.recordViolation('window_blur', 'Window lost focus');
                decrementAttempts(true);
            });

            window.addEventListener('focus', () => {
                this.lastActivityTime = Date.now();
            });
        }

        preventDebugging() {
            // Infinite debugger loop
            setInterval(() => {
                function detectDebugger() {
                    const start = new Date();
                    debugger;
                    const end = new Date();
                    if (end - start > 100) {
                        this.recordViolation('debugger_detected', 'Debugger execution detected');
                    }
                }
                detectDebugger.call(this);
            }, 1000);

            // Prevent step debugging
            (() => {
                function block() {
                    setInterval(() => {
                        (function() {
                            return false;
                        })['constructor']('debugger')['call']();
                    }, 50);
                }
                try {
                    block();
                } catch (e) {}
            })();
        }

        blockViewSource() {
            // Prevent view source
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'u') {
                    e.preventDefault();
                    this.recordViolation('view_source', 'View source attempted');
                    return false;
                }
            });
        }

        enterFullscreen() {
            // Try to enter fullscreen mode
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }

            // Monitor fullscreen exit
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    this.recordViolation('fullscreen_exit', 'Exited fullscreen mode');
                }
            });
        }

        startSecurityChecks() {
            this.securityCheckInterval = setInterval(() => {
                // Check for automation tools
                if (window.navigator.webdriver) {
                    this.recordViolation('automation', 'WebDriver detected');
                }

                // Check for suspicious properties
                if (window.chrome && window.chrome.runtime && window.chrome.runtime.onConnect) {
                    this.recordViolation('extension', 'Chrome extension detected');
                }

                // Check activity
                if (Date.now() - this.lastActivityTime > 300000) { // 5 minutes
                    this.recordViolation('inactivity', 'No activity for 5 minutes');
                }

                // Check window size (potential dev tools)
                if (window.outerHeight - window.innerHeight > 200) {
                    this.recordViolation('window_size', 'Suspicious window dimensions');
                }
            }, 5000);
        }

        recordViolation(type, message) {
            this.violations++;
            console.log(`Security violation #${this.violations}: ${type} - ${message}`);

            // Update modal
            document.getElementById('violationCount').textContent = this.violations;
            document.getElementById('securityMessage').textContent = `${message} (Type: ${type})`;

            // Show warning modal
            const modal = new bootstrap.Modal(document.getElementById('securityWarningModal'));
            modal.show();

            // Auto-submit if max violations reached
            if (this.violations >= this.maxViolations) {
                setTimeout(() => {
                    alert('Maximum security violations reached. Test will be automatically submitted.');
                    submitForm();
                }, 2000);
            }
        }
    }

    // Initialize variables
    let timeRemaining = @Model.Test.TimeLimit * 60;
    const timerElement = document.getElementById('timer');
    const progressBar = document.getElementById('progressBar');
    const currentQuestionNumber = document.getElementById('currentQuestionNumber');
    const totalQuestions = document.getElementById('totalQuestions');
    const questionTypeBadge = document.getElementById('questionTypeBadge');
    let formSubmitted = false;
    let remainingAttempts = parseInt(document.getElementById('remainingAttempts').value);
    const attemptId = document.getElementById('AttemptId').value;
    const modal = new bootstrap.Modal(document.getElementById('attemptWarningModal'));
    const submitModal = new bootstrap.Modal(document.getElementById('submitConfirmModal'));

    // Initialize anti-cheat system
    const antiCheat = new EnhancedAntiCheat();

    // Question navigation
    const questionContainers = document.querySelectorAll('.question-container');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const questionNavBtns = document.querySelectorAll('.question-nav-btn');
    let currentQuestionIndex = 0;

    // Track answered questions
    const questionStatus = new Array(questionContainers.length).fill(false);

    // Security warning acknowledgment
    function acknowledgeWarning() {
        const warningModal = bootstrap.Modal.getInstance(document.getElementById('securityWarningModal'));
        warningModal.hide();
    }

    // Timer logic
    function updateTimer() {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        // Change color based on time remaining
        if (timeRemaining <= 300) { // 5 minutes
            timerElement.classList.remove('bg-primary');
            timerElement.classList.add('bg-warning');
        }

        if (timeRemaining <= 120) { // 2 minutes
            timerElement.classList.remove('bg-warning');
            timerElement.classList.add('bg-danger', 'animate-pulse');
        }

        if (timeRemaining <= 0) {
            submitForm();
        } else {
            timeRemaining--;
        }
    }

    // Start timer
    let timerInterval;
    if (timeRemaining > 0) {
        timerInterval = setInterval(updateTimer, 1000);
    }

    // Form submission handler
    function submitForm() {
        if (formSubmitted) return;
        formSubmitted = true;
        clearInterval(timerInterval);
        if (antiCheat.securityCheckInterval) {
            clearInterval(antiCheat.securityCheckInterval);
        }
        document.getElementById('testForm').submit();
    }

    // Show question
    function showQuestion(index) {
        // Hide all questions
        questionContainers.forEach(container => container.style.display = 'none');

        // Show the current question
        questionContainers[index].style.display = 'block';

        // Update navigation buttons
        prevBtn.disabled = index === 0;
        nextBtn.style.display = index === questionContainers.length - 1 ? 'none' : 'block';
        submitBtn.style.display = index === questionContainers.length - 1 ? 'block' : 'none';

        // Update progress indicator
        currentQuestionNumber.textContent = index + 1;
        progressBar.style.width = `${((index + 1) / questionContainers.length) * 100}%`;
        progressBar.setAttribute('aria-valuenow', ((index + 1) / questionContainers.length) * 100);

        // Update question type badge
        const questionType = questionContainers[index].dataset.questionType;
        let badgeClass = 'bg-primary';
        let icon = '';

        switch(questionType) {
            case 'MultipleChoice':
                badgeClass = 'bg-primary';
                icon = 'list-ul';
                break;
            case 'TrueFalse':
                badgeClass = 'bg-success';
                icon = 'check-circle';
                break;
            case 'ShortAnswer':
                badgeClass = 'bg-info';
                icon = 'pen';
                break;
            case 'DragDrop':
                badgeClass = 'bg-warning';
                icon = 'hand-rock';
                break;
            case 'Table':
                badgeClass = 'bg-info';
                icon = 'table';
                break;
        }

        questionTypeBadge.className = `badge ${badgeClass}`;
        questionTypeBadge.innerHTML = `<i class="fas fa-${icon} me-1"></i>${questionType.replace(/([A-Z])/g, ' $1').trim()}`;

        // Update question navigation
        questionNavBtns.forEach(btn => {
            btn.classList.remove('active', 'btn-primary', 'btn-outline-secondary', 'btn-success');

            const btnIndex = parseInt(btn.dataset.questionIndex);
            if (btnIndex === index) {
                btn.classList.add('active', 'btn-primary');
            } else if (questionStatus[btnIndex]) {
                btn.classList.add('btn-success');
            } else {
                btn.classList.add('btn-outline-secondary');
            }
        });

        // Set current index
        currentQuestionIndex = index;
    }

    // Go to specific question
    function goToQuestion(index) {
        showQuestion(index);
    }

    // Navigation button handlers
    prevBtn.addEventListener('click', () => {
        if (currentQuestionIndex > 0) {
            showQuestion(currentQuestionIndex - 1);
        }
    });

    nextBtn.addEventListener('click', () => {
        if (currentQuestionIndex < questionContainers.length - 1) {
            showQuestion(currentQuestionIndex + 1);
        }
    });

    // Monitor answer changes
    function updateQuestionStatus() {
        questionContainers.forEach((container, index) => {
            const questionType = container.dataset.questionType;
            let isAnswered = false;

            switch(questionType) {
                case 'MultipleChoice':
                    const mcOptions = container.querySelectorAll('input[type="radio"], input[type="checkbox"]');
                    isAnswered = Array.from(mcOptions).some(option => option.checked);
                    break;
                case 'TrueFalse':
                    const tfOptions = container.querySelectorAll('input[type="radio"]');
                    isAnswered = Array.from(tfOptions).some(option => option.checked);
                    break;
                case 'ShortAnswer':
                    const saInput = container.querySelector('input[type="text"]');
                    isAnswered = saInput && saInput.value.trim() !== '';
                    break;
                case 'Table':
                    const tableInputs = container.querySelectorAll('.table-cell-input');
                    isAnswered = Array.from(tableInputs).some(input => input.checked);
                    break;
            }

            questionStatus[index] = isAnswered;

            // Update navigation button
            const navBtn = document.querySelector(`.question-nav-btn[data-question-index="${index}"]`);
            if (navBtn) {
                navBtn.classList.remove('btn-success', 'btn-outline-secondary');
                navBtn.classList.add(isAnswered ? 'btn-success' : 'btn-outline-secondary');
            }
        });
    }

    // Listen for input changes
    document.querySelectorAll('input[type="radio"], input[type="checkbox"], input[type="text"]').forEach(input => {
        input.addEventListener('change', updateQuestionStatus);

        // For text inputs, listen for keyup as well
        if (input.type === 'text') {
            input.addEventListener('keyup', updateQuestionStatus);
        }
    });

    // Submit button handler
    submitBtn.addEventListener('click', (e) => {
        e.preventDefault();

        // Count unanswered questions
        const unansweredCount = questionStatus.filter(status => !status).length;

        const unansweredWarning = document.getElementById('unansweredWarning');
        const unansweredCountElement = document.getElementById('unansweredCount');

        if (unansweredCount > 0) {
            unansweredWarning.style.display = 'block';
            unansweredCountElement.textContent = unansweredCount;
        } else {
            unansweredWarning.style.display = 'none';
        }

        // Show the confirmation modal
        submitModal.show();
    });

    // Confirm submit handler
    document.getElementById('confirmSubmitBtn').addEventListener('click', () => {
        submitForm();
    });

    // Flag to prevent multiple decrements
    let isAttemptDecremented = false;

    // Decrement attempts with modal notification
    async function decrementAttempts(showWarning = true) {
        if (remainingAttempts <= 0 || isAttemptDecremented) return;

        isAttemptDecremented = true; // Set flag to prevent multiple calls
        remainingAttempts--;
        document.getElementById('remainingAttempts').value = remainingAttempts;
        document.getElementById('remainingAttemptsCounter').textContent = remainingAttempts;
        document.getElementById('modalRemainingAttemptsCounter').textContent = remainingAttempts;

        try {
            const response = await fetch('/TestAttempt/UpdateRemainingAttempts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ attemptId, remainingAttempts })
            });

            if (!response.ok) throw new Error('Failed to update attempts');

            if (remainingAttempts <= 0) {
                submitForm();
            } else if (showWarning) {
                modal.show();
            }
        } catch (error) {
            console.error('Error:', error);
            remainingAttempts++; // Rollback on error
            document.getElementById('remainingAttemptsCounter').textContent = remainingAttempts;
        } finally {
            // Reset the flag after a short delay to allow future decrements
            setTimeout(() => {
                isAttemptDecremented = false;
            }, 1000); // 1-second delay
        }
    }

    // Enhanced visibility detection
    function handleVisibilityChange() {
        if (document.visibilityState === 'hidden') {
            decrementAttempts(true);
        }
    }

    // Enhanced focus/blur detection
    function handleFocusChange() {
        if (!document.hasFocus()) {
            decrementAttempts(true);
        }
    }

    // Attach event listeners
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('blur', handleFocusChange);
    window.addEventListener('focus', () => {
        antiCheat.lastActivityTime = Date.now();
    });

    // Navigation/closing detection
    window.addEventListener('beforeunload', (e) => {
        if (!formSubmitted) {
            e.preventDefault();
            e.returnValue = 'Are you sure you want to leave? Your remaining attempts will be decremented.';
            decrementAttempts(false);
        }
    });

    // Additional security measures
    document.addEventListener('paste', (e) => {
        if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
            e.preventDefault();
            antiCheat.recordViolation('paste_blocked', 'Paste operation blocked');
        }
    });

    // Prevent print screen
    document.addEventListener('keyup', (e) => {
        if (e.key === 'PrintScreen') {
            antiCheat.recordViolation('print_screen', 'Print Screen key detected');
        }
    });

    // Monitor mouse activity for automation detection
    let mouseEvents = 0;
    document.addEventListener('mousemove', () => {
        mouseEvents++;
        antiCheat.lastActivityTime = Date.now();
    });

    // Check for unusual mouse patterns
    setInterval(() => {
        if (mouseEvents === 0) {
            antiCheat.recordViolation('no_mouse_activity', 'No mouse movement detected');
        }
        mouseEvents = 0;
    }, 30000); // Check every 30 seconds

    // Prevent iframe injection
    if (window.self !== window.top) {
        antiCheat.recordViolation('iframe_detected', 'Page loaded in iframe');
        window.top.location = window.self.location;
    }

    // Check for headless browser
    if (navigator.webdriver || window.navigator.webdriver) {
        antiCheat.recordViolation('webdriver_detected', 'WebDriver detected');
    }

    // Check for common automation properties
    if (window.phantom || window._phantom || window.callPhantom) {
        antiCheat.recordViolation('phantom_detected', 'PhantomJS detected');
    }

    if (window.Buffer) {
        antiCheat.recordViolation('nodejs_detected', 'Node.js Buffer detected');
    }

    // Additional automation checks
    if (window.spawn || window.emit) {
        antiCheat.recordViolation('automation_detected', 'Automation tools detected');
    }

    // Initialize - show the first question
    showQuestion(0);
    updateQuestionStatus();

    // Add keyboard navigation
    document.addEventListener('keydown', (e) => {
        // Only respond to arrow keys if not in an input field
        if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
            return;
        }

        if (e.key === 'ArrowLeft' && currentQuestionIndex > 0) {
            showQuestion(currentQuestionIndex - 1);
        } else if (e.key === 'ArrowRight' && currentQuestionIndex < questionContainers.length - 1) {
            showQuestion(currentQuestionIndex + 1);
        }
    });

    // Custom radio/checkbox styling
    document.querySelectorAll('.custom-option').forEach(option => {
        option.addEventListener('click', function(e) {
            if (e.target.tagName !== 'INPUT') {
                const input = this.querySelector('input');
                input.checked = !input.checked;

                // Trigger change event for tracking answered status
                const event = new Event('change');
                input.dispatchEvent(event);
            }
        });
    });

    // Disable common browser shortcuts during test
    window.addEventListener('keydown', (e) => {
        // Block Ctrl+W (close tab)
        if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
            e.preventDefault();
            antiCheat.recordViolation('close_tab_attempt', 'Attempted to close tab');
        }

        // Block Ctrl+T (new tab)
        if ((e.ctrlKey || e.metaKey) && e.key === 't') {
            e.preventDefault();
            antiCheat.recordViolation('new_tab_attempt', 'Attempted to open new tab');
        }

        // Block Ctrl+N (new window)
        if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
            e.preventDefault();
            antiCheat.recordViolation('new_window_attempt', 'Attempted to open new window');
        }

        // Block Ctrl+Shift+T (restore tab)
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 't') {
            e.preventDefault();
            antiCheat.recordViolation('restore_tab_attempt', 'Attempted to restore tab');
        }
    }, true);

    // Detect if running in headless mode
    if (window.outerWidth === 0 && window.outerHeight === 0) {
        antiCheat.recordViolation('headless_detected', 'Headless browser detected');
    }

    // Check for missing browser features (indicates automation)
    if (!window.chrome || !window.chrome.runtime) {
        // This might be a normal browser, but combined with other factors could indicate automation
    }

    // Monitor for suspicious console activity
    let consoleCallCount = 0;
    const originalLog = console.log;
    console.log = function(...args) {
        consoleCallCount++;
        if (consoleCallCount > 10) {
            antiCheat.recordViolation('excessive_console', 'Excessive console usage detected');
        }
        return originalLog.apply(console, args);
    };

    // Final security check on page load
    setTimeout(() => {
        if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
            antiCheat.recordViolation('dev_tools_open', 'Developer tools appear to be open on load');
        }
    }, 2000);

    // Lock the page in fullscreen if possible
    function requestFullscreen() {
        const element = document.documentElement;
        if (element.requestFullscreen) {
            element.requestFullscreen().catch(() => {});
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    }

    // Request fullscreen after user interaction
    document.addEventListener('click', requestFullscreen, { once: true });
    document.addEventListener('keydown', requestFullscreen, { once: true });

    // Prevent back button
    history.pushState(null, null, location.href);
    window.addEventListener('popstate', () => {
        history.go(1);
        antiCheat.recordViolation('back_button', 'Back button usage detected');
    });

</script>
}